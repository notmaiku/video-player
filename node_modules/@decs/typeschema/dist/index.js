"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  assert: () => assert,
  validate: () => validate,
  wrap: () => wrap2
});
module.exports = __toCommonJS(src_exports);

// src/adapters/index.ts
function wrap(adapters) {
  return async (schema) => {
    const results = await Promise.all(
      adapters.map((adapter) => adapter(schema)).filter(Boolean)
    );
    if (results.length === 0) {
      throw new Error("Missing adapters for schema: " + schema);
    }
    if (results.length > 1) {
      throw new Error("Conflicting adapters for schema: " + schema);
    }
    return results[0];
  };
}

// src/utils.ts
function memoize(fn) {
  let cache = void 0;
  const memoizedFn = async () => {
    if (cache === void 0) {
      cache = await fn();
    }
    return cache;
  };
  memoizedFn.clear = () => cache = void 0;
  return memoizedFn;
}
function isTypeBoxSchema(schema) {
  return Symbol.for("TypeBox.Kind") in schema;
}
function isJSONSchema(schema) {
  return typeof schema === "object" && !("validate" in schema) && !("kind" in schema) && !("parse" in schema) && !("_parse" in schema) && !("ast" in schema) && !isTypeBoxSchema(schema);
}

// src/adapters/ajv.ts
var fetchModule = /* @__PURE__ */ memoize(async () => {
  try {
    const { default: Ajv } = await import(
      /* webpackIgnore: true */
      "ajv"
    );
    return new Ajv();
  } catch (error) {
    throw error;
  }
});
var coerce = /* @__NO_SIDE_EFFECTS__ */ (fn) => (schema) => isJSONSchema(schema) ? fn(schema) : void 0;
var createValidate = /* @__PURE__ */ coerce(async (schema) => {
  const ajv = await fetchModule();
  const validateSchema = ajv.compile(schema);
  return async (data) => {
    if (validateSchema(data)) {
      return {
        data,
        success: true
      };
    }
    return {
      issues: (validateSchema.errors ?? []).map(({ message, schemaPath }) => ({
        message: message ?? "",
        path: [schemaPath]
      })),
      success: false
    };
  };
});

// src/adapters/arktype.ts
var coerce2 = /* @__NO_SIDE_EFFECTS__ */ (fn) => (schema) => "infer" in schema && !isTypeBoxSchema(schema) && !isJSONSchema(schema) ? fn(schema) : void 0;
var createValidate2 = /* @__PURE__ */ coerce2(
  async (schema) => async (data) => {
    const result = schema(data);
    if (result.problems == null) {
      return {
        data: result.data,
        success: true
      };
    }
    return {
      issues: Array.from(result.problems).map(({ message, path }) => ({
        message,
        path
      })),
      success: false
    };
  }
);

// src/adapters/custom.ts
var coerce3 = /* @__NO_SIDE_EFFECTS__ */ (fn) => (schema) => typeof schema === "function" && !("assert" in schema) ? fn(schema) : void 0;
var createValidate3 = /* @__PURE__ */ coerce3(
  async (schema) => async (data) => {
    try {
      return {
        data: await schema(data),
        success: true
      };
    } catch (error) {
      if (error instanceof Error) {
        return {
          issues: [{ message: error.message }],
          success: false
        };
      }
      throw error;
    }
  }
);

// src/adapters/deepkit.ts
var fetchModule2 = /* @__PURE__ */ memoize(async () => {
  try {
    const { validate: validate2 } = await import(
      /* webpackIgnore: true */
      "@deepkit/type"
    );
    return { validate: validate2 };
  } catch (error) {
    throw error;
  }
});
var coerce4 = /* @__NO_SIDE_EFFECTS__ */ (fn) => (schema) => "kind" in schema && !isTypeBoxSchema(schema) && !isJSONSchema(schema) ? fn(schema) : void 0;
var createValidate4 = /* @__PURE__ */ coerce4(async (schema) => {
  const { validate: validate2 } = await fetchModule2();
  return async (data) => {
    const result = validate2(data, schema);
    if (result.length === 0) {
      return {
        data,
        success: true
      };
    }
    return {
      issues: result.map(({ message, path }) => ({ message, path: [path] })),
      success: false
    };
  };
});

// src/adapters/effect.ts
var fetchModule3 = /* @__PURE__ */ memoize(async () => {
  try {
    const { isRight } = await import(
      /* webpackIgnore: true */
      "effect/Either"
    );
    const { isSchema, parseEither } = await import(
      /* webpackIgnore: true */
      "@effect/schema/Schema"
    );
    const { formatError } = await import(
      /* webpackIgnore: true */
      "@effect/schema/TreeFormatter"
    );
    return { formatError, isRight, isSchema, parseEither };
  } catch (error) {
    throw error;
  }
});
var coerce5 = /* @__NO_SIDE_EFFECTS__ */ (fn) => (schema) => {
  return "ast" in schema && !isJSONSchema(schema) && !isTypeBoxSchema(schema) ? fn(schema) : void 0;
};
var createValidate5 = /* @__PURE__ */ coerce5(async (schema) => {
  const { parseEither, isRight, formatError } = await fetchModule3();
  const parseSchema = parseEither(schema);
  return async (data) => {
    const result = parseSchema(data);
    if (isRight(result)) {
      return {
        data: result.right,
        success: true
      };
    }
    return {
      issues: [{ message: formatError(result.left) }],
      success: false
    };
  };
});

// src/adapters/io-ts.ts
var fetchModule4 = /* @__PURE__ */ memoize(async () => {
  try {
    const { isRight } = await import(
      /* webpackIgnore: true */
      "fp-ts/Either"
    );
    return { isRight };
  } catch (error) {
    throw error;
  }
});
var coerce6 = /* @__NO_SIDE_EFFECTS__ */ (fn) => (schema) => "encode" in schema && !isTypeBoxSchema(schema) && !isJSONSchema(schema) ? fn(schema) : void 0;
var createValidate6 = /* @__PURE__ */ coerce6(async (schema) => {
  const { isRight } = await fetchModule4();
  return async (data) => {
    const result = schema.decode(data);
    if (isRight(result)) {
      return {
        data: result.right,
        success: true
      };
    }
    return {
      issues: result.left.map(({ message, context }) => ({
        message: message ?? "",
        path: context.map(({ key }) => key)
      })),
      success: false
    };
  };
});

// src/adapters/joi.ts
var coerce7 = /* @__NO_SIDE_EFFECTS__ */ (fn) => (schema) => "_flags" in schema && !isTypeBoxSchema(schema) && !isJSONSchema(schema) ? fn(schema) : void 0;
var createValidate7 = /* @__PURE__ */ coerce7(
  async (schema) => async (data) => {
    const result = schema.validate(data);
    if (result.error == null) {
      return {
        data: result.value,
        success: true
      };
    }
    return {
      issues: result.error.details.map(({ message, path }) => ({
        message,
        path
      })),
      success: false
    };
  }
);

// src/adapters/ow.ts
var fetchModule5 = /* @__PURE__ */ memoize(async () => {
  try {
    const { default: ow, ArgumentError } = await import(
      /* webpackIgnore: true */
      "ow"
    );
    return { ArgumentError, ow };
  } catch (error) {
    throw error;
  }
});
var coerce8 = /* @__NO_SIDE_EFFECTS__ */ (fn) => (schema) => "context" in schema && !isTypeBoxSchema(schema) && !isJSONSchema(schema) ? fn(schema) : void 0;
var createValidate8 = /* @__PURE__ */ coerce8(async (schema) => {
  const { ow, ArgumentError } = await fetchModule5();
  const assertSchema = ow.create(schema);
  return async (data) => {
    try {
      assertSchema(data);
      return {
        data,
        success: true
      };
    } catch (error) {
      if (error instanceof ArgumentError) {
        return {
          issues: Array.from(error.validationErrors.values()).flatMap(
            (messages) => Array.from(messages).map((message) => ({ message }))
          ),
          success: false
        };
      }
      throw error;
    }
  };
});

// src/adapters/runtypes.ts
var coerce9 = /* @__NO_SIDE_EFFECTS__ */ (fn) => (schema) => "reflect" in schema && !isTypeBoxSchema(schema) && !isJSONSchema(schema) ? fn(schema) : void 0;
var createValidate9 = /* @__PURE__ */ coerce9(
  async (schema) => async (data) => {
    const result = schema.validate(data);
    if (result.success) {
      return {
        data: result.value,
        success: true
      };
    }
    return {
      issues: [{ message: result.message }],
      success: false
    };
  }
);

// src/adapters/superstruct.ts
var coerce10 = /* @__NO_SIDE_EFFECTS__ */ (fn) => (schema) => "refiner" in schema && !isTypeBoxSchema(schema) && !isJSONSchema(schema) ? fn(schema) : void 0;
var createValidate10 = /* @__PURE__ */ coerce10(
  async (schema) => async (data) => {
    const result = schema.validate(data, { coerce: true });
    if (result[0] == null) {
      return {
        data: result[1],
        success: true
      };
    }
    const { message, path } = result[0];
    return {
      issues: [{ message, path }],
      success: false
    };
  }
);

// src/adapters/typebox.ts
var fetchModule6 = /* @__PURE__ */ memoize(async () => {
  try {
    const { TypeCompiler } = await import(
      /* webpackIgnore: true */
      "@sinclair/typebox/compiler"
    );
    return { TypeCompiler };
  } catch (error) {
    throw error;
  }
});
var coerce11 = /* @__NO_SIDE_EFFECTS__ */ (fn) => (schema) => isTypeBoxSchema(schema) ? fn(schema) : void 0;
var createValidate11 = /* @__PURE__ */ coerce11(async (schema) => {
  const { TypeCompiler } = await fetchModule6();
  const result = TypeCompiler.Compile(schema);
  return async (data) => {
    if (result.Check(data)) {
      return {
        data,
        success: true
      };
    }
    return {
      issues: [...result.Errors(data)].map(({ message, path }) => ({
        message,
        path: [path]
      })),
      success: false
    };
  };
});

// src/adapters/valibot.ts
var fetchModule7 = /* @__PURE__ */ memoize(async () => {
  try {
    const { safeParseAsync } = await import(
      /* webpackIgnore: true */
      "valibot"
    );
    return { safeParseAsync };
  } catch (error) {
    throw error;
  }
});
var coerce12 = /* @__NO_SIDE_EFFECTS__ */ (fn) => (schema) => "async" in schema && !isTypeBoxSchema(schema) && !isJSONSchema(schema) ? fn(schema) : void 0;
var createValidate12 = /* @__PURE__ */ coerce12(async (schema) => {
  const { safeParseAsync } = await fetchModule7();
  return async (data) => {
    const result = await safeParseAsync(schema, data);
    if (result.success) {
      return {
        data: result.output,
        success: true
      };
    }
    return {
      issues: result.issues.map(({ message, path }) => ({
        message,
        path: path?.map(
          ({ type, key }) => type === "map" || type === "unknown" ? String(key) : key
        )
      })),
      success: false
    };
  };
});

// src/adapters/yup.ts
var fetchModule8 = /* @__PURE__ */ memoize(async () => {
  try {
    const { ValidationError } = await import(
      /* webpackIgnore: true */
      "yup"
    );
    return { ValidationError };
  } catch (error) {
    throw error;
  }
});
var coerce13 = /* @__NO_SIDE_EFFECTS__ */ (fn) => (schema) => "__isYupSchema__" in schema && !isTypeBoxSchema(schema) && !isJSONSchema(schema) ? fn(schema) : void 0;
var createValidate13 = /* @__PURE__ */ coerce13(async (schema) => {
  const { ValidationError } = await fetchModule8();
  return async (data) => {
    try {
      return {
        data: await schema.validate(data, { strict: true }),
        success: true
      };
    } catch (error) {
      if (error instanceof ValidationError) {
        const { message, path } = error;
        return {
          issues: [
            {
              message,
              path: path != null && path !== "" ? [path] : void 0
            }
          ],
          success: false
        };
      }
      throw error;
    }
  };
});

// src/adapters/zod.ts
var coerce14 = /* @__NO_SIDE_EFFECTS__ */ (fn) => (schema) => "_def" in schema && !isTypeBoxSchema(schema) && !isJSONSchema(schema) ? fn(schema) : void 0;
var createValidate14 = /* @__PURE__ */ coerce14(
  async (schema) => async (data) => {
    const result = await schema.safeParseAsync(data);
    if (result.success) {
      return {
        data: result.data,
        success: true
      };
    }
    return {
      issues: result.error.issues.map(({ message, path }) => ({ message, path })),
      success: false
    };
  }
);

// src/registry.ts
var createValidate15 = /* @__PURE__ */ wrap([
  createValidate,
  createValidate2,
  createValidate3,
  createValidate4,
  createValidate5,
  createValidate6,
  createValidate7,
  createValidate8,
  createValidate9,
  createValidate10,
  createValidate11,
  createValidate12,
  createValidate13,
  createValidate14
]);

// src/validation.ts
async function validate(schema, data) {
  const validateSchema = await createValidate15(schema);
  return validateSchema(data);
}
async function assert(schema, data) {
  const result = await validate(schema, data);
  if (result.success) {
    return result.data;
  }
  throw new AggregateError(result.issues, "Assertion failed");
}

// src/wrap.ts
function wrap2(schema) {
  return {
    _input: void 0,
    _output: void 0,
    assert: (data) => assert(schema, data),
    parse: (data) => assert(schema, data),
    validate: (data) => validate(schema, data)
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assert,
  validate,
  wrap
});
